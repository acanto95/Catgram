/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { NG_VALIDATORS } from '@angular/forms';
import { Directive, forwardRef, Input } from '@angular/core';
import { NgbDate } from './ngb-date';
import { NgbCalendar } from './ngb-calendar';
/**
 * @param {?} value
 * @return {?}
 */
function isNgbDateStruct(value) {
    return value && value.day && value.month && value.year;
}
/**
 * A class containing factories for datepicker validator functions:
 * * `NgbDateValidators.minDate(minDate: NgbDateStruct)` - checks that the date is after the min date
 * * `NgbDateValidators.maxDate(maxDate: NgbDateStruct)` - checks that the date is before the max date
 * * `NgbDateValidators.invalidDate(calendar: NgbCalendar)` - checks that the date is valid
 *
 * \@since 4.2.0
 */
// @dynamic
var /**
 * A class containing factories for datepicker validator functions:
 * * `NgbDateValidators.minDate(minDate: NgbDateStruct)` - checks that the date is after the min date
 * * `NgbDateValidators.maxDate(maxDate: NgbDateStruct)` - checks that the date is before the max date
 * * `NgbDateValidators.invalidDate(calendar: NgbCalendar)` - checks that the date is valid
 *
 * \@since 4.2.0
 */
// @dynamic
NgbDateValidators = /** @class */ (function () {
    function NgbDateValidators() {
    }
    /**
     * @param {?} minDate
     * @return {?}
     */
    NgbDateValidators.minDate = /**
     * @param {?} minDate
     * @return {?}
     */
    function (minDate) {
        return function (control) {
            if (!isNgbDateStruct(control.value) || !isNgbDateStruct(minDate)) {
                return null;
            }
            /** @type {?} */
            var ngbDate = NgbDate.from(control.value);
            return ngbDate.before(NgbDate.from(minDate)) ? { 'ngbDate': { requiredBefore: minDate } } : null;
        };
    };
    /**
     * @param {?} maxDate
     * @return {?}
     */
    NgbDateValidators.maxDate = /**
     * @param {?} maxDate
     * @return {?}
     */
    function (maxDate) {
        return function (control) {
            if (!isNgbDateStruct(control.value) || !isNgbDateStruct(maxDate)) {
                return null;
            }
            /** @type {?} */
            var ngbDate = NgbDate.from(control.value);
            return ngbDate.after(NgbDate.from(maxDate)) ? { 'ngbDate': { requiredAfter: maxDate } } : null;
        };
    };
    /**
     * @param {?} calendar
     * @return {?}
     */
    NgbDateValidators.invalidDate = /**
     * @param {?} calendar
     * @return {?}
     */
    function (calendar) {
        return function (control) { return calendar.isValid(control.value) ? null : { 'ngbDate': { invalid: control.value } }; };
    };
    return NgbDateValidators;
}());
/**
 * A class containing factories for datepicker validator functions:
 * * `NgbDateValidators.minDate(minDate: NgbDateStruct)` - checks that the date is after the min date
 * * `NgbDateValidators.maxDate(maxDate: NgbDateStruct)` - checks that the date is before the max date
 * * `NgbDateValidators.invalidDate(calendar: NgbCalendar)` - checks that the date is valid
 *
 * \@since 4.2.0
 */
// @dynamic
export { NgbDateValidators };
/**
 * A provider which adds `NgbInvalidDateValidator` to the `NG_VALIDATORS` multi-provider list.
 * @type {?}
 */
var NGB_INVALID_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return NgbInvalidDateValidator; }),
    multi: true
};
/**
 * A directive that adds date validation to all NgbInputDatepicker controls. The directive is provided with the
 * `NG_VALIDATORS` multi-provider list.
 *
 * \@since 4.2.0
 */
var NgbInvalidDateValidator = /** @class */ (function () {
    function NgbInvalidDateValidator(_calendar) {
        this._calendar = _calendar;
        this._validator = NgbDateValidators.invalidDate(this._calendar);
    }
    /**
     * @param {?} control
     * @return {?}
     */
    NgbInvalidDateValidator.prototype.validate = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return control.value == null ? null : this._validator(control);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgbInvalidDateValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChange = fn; };
    NgbInvalidDateValidator.decorators = [
        { type: Directive, args: [{
                    selector: 'input[ngbDatepicker][formControlName],input[ngbDatepicker][formControl],input[ngbDatepicker][ngModel]',
                    providers: [NGB_INVALID_DATE_VALIDATOR]
                },] }
    ];
    /** @nocollapse */
    NgbInvalidDateValidator.ctorParameters = function () { return [
        { type: NgbCalendar }
    ]; };
    return NgbInvalidDateValidator;
}());
export { NgbInvalidDateValidator };
if (false) {
    /** @type {?} */
    NgbInvalidDateValidator.prototype._validator;
    /** @type {?} */
    NgbInvalidDateValidator.prototype._onChange;
    /** @type {?} */
    NgbInvalidDateValidator.prototype._calendar;
}
/**
 * A provider which adds `NgbMinDateValidator` to the `NG_VALIDATORS` multi-provider list.
 * @type {?}
 */
var NGB_MIN_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return NgbMinDateValidator; }),
    multi: true
};
/**
 * A directive that adds min date validation to all NgbInputDatepicker controls with the `minDate` attribute. The
 * directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * \@since 4.2.0
 */
var NgbMinDateValidator = /** @class */ (function () {
    function NgbMinDateValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgbMinDateValidator.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('minDate' in changes) {
            this._createValidator();
            if (this._onChange) {
                this._onChange();
            }
        }
    };
    /**
     * @param {?} control
     * @return {?}
     */
    NgbMinDateValidator.prototype.validate = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this.minDate == null ? null : this._validator(control);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgbMinDateValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChange = fn; };
    /**
     * @return {?}
     */
    NgbMinDateValidator.prototype._createValidator = /**
     * @return {?}
     */
    function () { this._validator = NgbDateValidators.minDate(this.minDate); };
    NgbMinDateValidator.decorators = [
        { type: Directive, args: [{
                    selector: 'input[ngbDatepicker][minDate][formControlName],input[ngbDatepicker][minDate][formControl],input[ngbDatepicker][minDate][ngModel]',
                    providers: [NGB_MIN_DATE_VALIDATOR]
                },] }
    ];
    NgbMinDateValidator.propDecorators = {
        minDate: [{ type: Input }]
    };
    return NgbMinDateValidator;
}());
export { NgbMinDateValidator };
if (false) {
    /** @type {?} */
    NgbMinDateValidator.prototype._validator;
    /** @type {?} */
    NgbMinDateValidator.prototype._onChange;
    /** @type {?} */
    NgbMinDateValidator.prototype.minDate;
}
/**
 * A provider which adds `NgbMaxDateValidator` to the `NG_VALIDATORS` multi-provider list.
 * @type {?}
 */
var NGB_MAX_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return NgbMaxDateValidator; }),
    multi: true
};
/**
 * A directive that adds max date validation to all NgbInputDatepicker controls with the `maxDate` attribute. The
 * directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * \@since 4.2.0
 */
var NgbMaxDateValidator = /** @class */ (function () {
    function NgbMaxDateValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgbMaxDateValidator.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('maxDate' in changes) {
            this._createValidator();
            if (this._onChange) {
                this._onChange();
            }
        }
    };
    /**
     * @param {?} control
     * @return {?}
     */
    NgbMaxDateValidator.prototype.validate = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this.maxDate == null ? null : this._validator(control);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgbMaxDateValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChange = fn; };
    /**
     * @return {?}
     */
    NgbMaxDateValidator.prototype._createValidator = /**
     * @return {?}
     */
    function () { this._validator = NgbDateValidators.maxDate(this.maxDate); };
    NgbMaxDateValidator.decorators = [
        { type: Directive, args: [{
                    selector: 'input[ngbDatepicker][maxDate][formControlName],input[ngbDatepicker][maxDate][formControl],input[ngbDatepicker][maxDate][ngModel]',
                    providers: [NGB_MAX_DATE_VALIDATOR]
                },] }
    ];
    NgbMaxDateValidator.propDecorators = {
        maxDate: [{ type: Input }]
    };
    return NgbMaxDateValidator;
}());
export { NgbMaxDateValidator };
if (false) {
    /** @type {?} */
    NgbMaxDateValidator.prototype._validator;
    /** @type {?} */
    NgbMaxDateValidator.prototype._onChange;
    /** @type {?} */
    NgbMaxDateValidator.prototype.maxDate;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci12YWxpZGF0b3JzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvIiwic291cmNlcyI6WyJkYXRlcGlja2VyL2RhdGVwaWNrZXItdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFrQixhQUFhLEVBQTJDLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEcsT0FBTyxFQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUEyQyxNQUFNLGVBQWUsQ0FBQztBQUVyRyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ25DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFFM0MsU0FBUyxlQUFlLENBQUMsS0FBVTtJQUNqQyxPQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQztBQUN6RCxDQUFDOzs7Ozs7Ozs7O0FBV0Q7Ozs7Ozs7Ozs7SUFBQTtJQXVCQSxDQUFDOzs7OztJQXRCUSx5QkFBTzs7OztJQUFkLFVBQWUsT0FBc0I7UUFDbkMsT0FBTyxVQUFDLE9BQXdCO1lBQzlCLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNoRSxPQUFPLElBQUksQ0FBQzthQUNiOztnQkFDSyxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1lBQzNDLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsU0FBUyxFQUFFLEVBQUMsY0FBYyxFQUFFLE9BQU8sRUFBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUMv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QyxPQUFPLENBQUMsQ0FBQztJQUNoRSxDQUFDOzs7OztJQUVELHVEQUF5Qjs7OztJQUF6QixVQUEwQixFQUFjLElBQVUsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDOzs7O0lBRWhFLDhDQUFnQjs7O0lBQXhCLGNBQW1DLElBQUksQ0FBQyxVQUFVLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7O2dCQXpCaEcsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFDSixrSUFBa0k7b0JBQ3RJLFNBQVMsRUFBRSxDQUFDLHNCQUFzQixDQUFDO2lCQUNwQzs7OzBCQUtFLEtBQUs7O0lBaUJSLDBCQUFDO0NBQUEsQUExQkQsSUEwQkM7U0FyQlksbUJBQW1COzs7SUFFOUIseUNBQWdDOztJQUNoQyx3Q0FBOEI7O0lBQzlCLHNDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0RpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgU3RhdGljUHJvdmlkZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOZ2JEYXRlU3RydWN0fSBmcm9tICcuL25nYi1kYXRlLXN0cnVjdCc7XG5pbXBvcnQge05nYkRhdGV9IGZyb20gJy4vbmdiLWRhdGUnO1xuaW1wb3J0IHtOZ2JDYWxlbmRhcn0gZnJvbSAnLi9uZ2ItY2FsZW5kYXInO1xuXG5mdW5jdGlvbiBpc05nYkRhdGVTdHJ1Y3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuZGF5ICYmIHZhbHVlLm1vbnRoICYmIHZhbHVlLnllYXI7XG59XG5cbi8qKlxuICogQSBjbGFzcyBjb250YWluaW5nIGZhY3RvcmllcyBmb3IgZGF0ZXBpY2tlciB2YWxpZGF0b3IgZnVuY3Rpb25zOlxuICogKiBgTmdiRGF0ZVZhbGlkYXRvcnMubWluRGF0ZShtaW5EYXRlOiBOZ2JEYXRlU3RydWN0KWAgLSBjaGVja3MgdGhhdCB0aGUgZGF0ZSBpcyBhZnRlciB0aGUgbWluIGRhdGVcbiAqICogYE5nYkRhdGVWYWxpZGF0b3JzLm1heERhdGUobWF4RGF0ZTogTmdiRGF0ZVN0cnVjdClgIC0gY2hlY2tzIHRoYXQgdGhlIGRhdGUgaXMgYmVmb3JlIHRoZSBtYXggZGF0ZVxuICogKiBgTmdiRGF0ZVZhbGlkYXRvcnMuaW52YWxpZERhdGUoY2FsZW5kYXI6IE5nYkNhbGVuZGFyKWAgLSBjaGVja3MgdGhhdCB0aGUgZGF0ZSBpcyB2YWxpZFxuICpcbiAqIEBzaW5jZSA0LjIuMFxuICovXG4vLyBAZHluYW1pY1xuZXhwb3J0IGNsYXNzIE5nYkRhdGVWYWxpZGF0b3JzIHtcbiAgc3RhdGljIG1pbkRhdGUobWluRGF0ZTogTmdiRGF0ZVN0cnVjdCk6IFZhbGlkYXRvckZuIHtcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGlmICghaXNOZ2JEYXRlU3RydWN0KGNvbnRyb2wudmFsdWUpIHx8ICFpc05nYkRhdGVTdHJ1Y3QobWluRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBuZ2JEYXRlID0gTmdiRGF0ZS5mcm9tKGNvbnRyb2wudmFsdWUpO1xuICAgICAgcmV0dXJuIG5nYkRhdGUuYmVmb3JlKE5nYkRhdGUuZnJvbShtaW5EYXRlKSkgPyB7J25nYkRhdGUnOiB7cmVxdWlyZWRCZWZvcmU6IG1pbkRhdGV9fSA6IG51bGw7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgbWF4RGF0ZShtYXhEYXRlOiBOZ2JEYXRlU3RydWN0KTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgaWYgKCFpc05nYkRhdGVTdHJ1Y3QoY29udHJvbC52YWx1ZSkgfHwgIWlzTmdiRGF0ZVN0cnVjdChtYXhEYXRlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5nYkRhdGUgPSBOZ2JEYXRlLmZyb20oY29udHJvbC52YWx1ZSk7XG4gICAgICByZXR1cm4gbmdiRGF0ZS5hZnRlcihOZ2JEYXRlLmZyb20obWF4RGF0ZSkpID8geyduZ2JEYXRlJzoge3JlcXVpcmVkQWZ0ZXI6IG1heERhdGV9fSA6IG51bGw7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW52YWxpZERhdGUoY2FsZW5kYXI6IE5nYkNhbGVuZGFyKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8XG4gICAgICAgIG51bGwgPT4geyByZXR1cm4gY2FsZW5kYXIuaXNWYWxpZChjb250cm9sLnZhbHVlKSA/IG51bGwgOiB7J25nYkRhdGUnOiB7aW52YWxpZDogY29udHJvbC52YWx1ZX19OyB9O1xuICB9XG59XG5cbi8qKlxuICogQSBwcm92aWRlciB3aGljaCBhZGRzIGBOZ2JJbnZhbGlkRGF0ZVZhbGlkYXRvcmAgdG8gdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0aS1wcm92aWRlciBsaXN0LlxuICovXG5jb25zdCBOR0JfSU5WQUxJRF9EQVRFX1ZBTElEQVRPUjogU3RhdGljUHJvdmlkZXIgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5nYkludmFsaWREYXRlVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGRhdGUgdmFsaWRhdGlvbiB0byBhbGwgTmdiSW5wdXREYXRlcGlja2VyIGNvbnRyb2xzLiBUaGUgZGlyZWN0aXZlIGlzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqXG4gKiBAc2luY2UgNC4yLjBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbbmdiRGF0ZXBpY2tlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFtuZ2JEYXRlcGlja2VyXVtmb3JtQ29udHJvbF0saW5wdXRbbmdiRGF0ZXBpY2tlcl1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtOR0JfSU5WQUxJRF9EQVRFX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgTmdiSW52YWxpZERhdGVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IF92YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIF9vbkNoYW5nZTogKCkgPT4gdm9pZDtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2FsZW5kYXI6IE5nYkNhbGVuZGFyKSB7IHRoaXMuX3ZhbGlkYXRvciA9IE5nYkRhdGVWYWxpZGF0b3JzLmludmFsaWREYXRlKHRoaXMuX2NhbGVuZGFyKTsgfVxuXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICByZXR1cm4gY29udHJvbC52YWx1ZSA9PSBudWxsID8gbnVsbCA6IHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfVxufVxuXG4vKipcbiAqIEEgcHJvdmlkZXIgd2hpY2ggYWRkcyBgTmdiTWluRGF0ZVZhbGlkYXRvcmAgdG8gdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0aS1wcm92aWRlciBsaXN0LlxuICovXG5jb25zdCBOR0JfTUlOX0RBVEVfVkFMSURBVE9SOiBTdGF0aWNQcm92aWRlciA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdiTWluRGF0ZVZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWRkcyBtaW4gZGF0ZSB2YWxpZGF0aW9uIHRvIGFsbCBOZ2JJbnB1dERhdGVwaWNrZXIgY29udHJvbHMgd2l0aCB0aGUgYG1pbkRhdGVgIGF0dHJpYnV0ZS4gVGhlXG4gKiBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNpbmNlIDQuMi4wXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjpcbiAgICAgICdpbnB1dFtuZ2JEYXRlcGlja2VyXVttaW5EYXRlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W25nYkRhdGVwaWNrZXJdW21pbkRhdGVdW2Zvcm1Db250cm9sXSxpbnB1dFtuZ2JEYXRlcGlja2VyXVttaW5EYXRlXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW05HQl9NSU5fREFURV9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE5nYk1pbkRhdGVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsXG4gICAgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBfb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG4gIEBJbnB1dCgpIG1pbkRhdGU6IE5nYkRhdGVTdHJ1Y3Q7XG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoJ21pbkRhdGUnIGluIGNoYW5nZXMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLm1pbkRhdGUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH1cblxuICBwcml2YXRlIF9jcmVhdGVWYWxpZGF0b3IoKTogdm9pZCB7IHRoaXMuX3ZhbGlkYXRvciA9IE5nYkRhdGVWYWxpZGF0b3JzLm1pbkRhdGUodGhpcy5taW5EYXRlKTsgfVxufVxuXG4vKipcbiAqIEEgcHJvdmlkZXIgd2hpY2ggYWRkcyBgTmdiTWF4RGF0ZVZhbGlkYXRvcmAgdG8gdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0aS1wcm92aWRlciBsaXN0LlxuICovXG5jb25zdCBOR0JfTUFYX0RBVEVfVkFMSURBVE9SOiBTdGF0aWNQcm92aWRlciA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdiTWF4RGF0ZVZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWRkcyBtYXggZGF0ZSB2YWxpZGF0aW9uIHRvIGFsbCBOZ2JJbnB1dERhdGVwaWNrZXIgY29udHJvbHMgd2l0aCB0aGUgYG1heERhdGVgIGF0dHJpYnV0ZS4gVGhlXG4gKiBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNpbmNlIDQuMi4wXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjpcbiAgICAgICdpbnB1dFtuZ2JEYXRlcGlja2VyXVttYXhEYXRlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W25nYkRhdGVwaWNrZXJdW21heERhdGVdW2Zvcm1Db250cm9sXSxpbnB1dFtuZ2JEYXRlcGlja2VyXVttYXhEYXRlXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW05HQl9NQVhfREFURV9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE5nYk1heERhdGVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsXG4gICAgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBfb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG4gIEBJbnB1dCgpIG1heERhdGU6IE5nYkRhdGVTdHJ1Y3Q7XG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoJ21heERhdGUnIGluIGNoYW5nZXMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLm1heERhdGUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH1cblxuICBwcml2YXRlIF9jcmVhdGVWYWxpZGF0b3IoKTogdm9pZCB7IHRoaXMuX3ZhbGlkYXRvciA9IE5nYkRhdGVWYWxpZGF0b3JzLm1heERhdGUodGhpcy5tYXhEYXRlKTsgfVxufVxuIl19